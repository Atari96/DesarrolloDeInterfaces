@page "/myorders/{orderId:int}"
@attribute [Authorize]
@using System.Threading    
@inject OrdersClient OrdersClient
@implements IDisposable // Interfaz que utilizamos para evitar y cancelar solicitudes para que no se sobrecargue la memoria

@*<summary>
    Interfaz que utilizamos para evitar y cancelar solicitudes para que no se sobrecargue la memoria
    Pagina que gestiona los estados de un pedido
    Caso en el que el pedido no es valido, nulo o
    Caso en el que el pedido es correcto, establece el estado del pedido, muestra detalles, y muestra plano localizacion
    Método OnparametersSets(), permite al componente mantenerse actualizado con el estado del pedido en todo momento
    Metodo PollForUpdates(), Metodo para obtener actualizaciones del estado de un pedido
    Incluimos el manejo de la excepcion que puede ser producida por un token no valido
    cambiamos el estado del pedido, hay que esperar a que llegue el pedido segun su id
    El metodo stateHasChanged hace que se produzca una actualizacion del estado
    Establece un tiempo de espera para poder observar que va cambiando de estado
    Metodo que nos permite liberar la memoria en caso de cancelar las peticiones
</summary>*@


<PageTitle>Blazing Pizza - Detalles del pedido</PageTitle>
<!-- Pagina que gestiona los estados de un pedido -->

<div class="main">
    <!-- Caso en el que el pedido no es valido-->
    @if (invalidOrder)  
    {
        <h2>Nada que mostrar</h2>
        <p>Lo sentimos, este pedido no puede ser cargado.</p>
    }
    <!-- Caso en el que el pedido es nulo -->
    else if (orderWithStatus is null)
    {
        <text>Cargando...</text>
    }
    else
    {
    <!-- Caso en el que el pedido es correcto, establece el estado del pedido, muestra detalles, y muestra plano localizacion-->
        <div class="track-order">
            <div class="track-order-title">
                <h2>
                    Pedido realizado @orderWithStatus.Order.CreatedTime.ToLongDateString()
                </h2>
                <p class="ml-auto mb-0">
                    Estado: <strong>@orderWithStatus.StatusText</strong>
                </p>
            </div>
            <div class="track-order-body">
                <div class="track-order-details">
                    <OrderReview Order="orderWithStatus.Order" />
                </div>
            
                <!-- Apartado que nos permitirá mostrar la localización del pedido-->
                <div class="track-order-map">
                    <Map Zoom="13" Markers="orderWithStatus.MapMarkers" />
                </div>
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public int OrderId { get; set; }

    OrderWithStatus? orderWithStatus;
    bool invalidOrder;
    CancellationTokenSource? pollingCancellationToken;

    // Permite al componente mantenerse actualizado con el estado del pedido en todo momento
    protected override void OnParametersSet()
    {
        // If we were already polling for a different order, stop doing so
        pollingCancellationToken?.Cancel();

        // Start a new poll loop
        PollForUpdates();
    }

    // Metodo para obtener actualizaciones del estado de un pedido
    private async void PollForUpdates()
    {
        invalidOrder = false;
        pollingCancellationToken = new CancellationTokenSource();
        while (!pollingCancellationToken.IsCancellationRequested)
        {
            // Incluimos el manejo de la excepcion que puede ser producida por un token no valido
            try
            {
                // cambiamos el estado del pedido, hay que esperar a que llegue el pedido segun su id
                orderWithStatus = await OrdersClient.GetOrder(OrderId);
                // El metodo stateHasChanged hace que se produzca una actualizacion del estado
                StateHasChanged();

                if (orderWithStatus.IsDelivered)
                {
                    pollingCancellationToken.Cancel();
                }
                else
                {
                    // Establece un tiempo de espera para poder observar que va cambiando de estado
                    await Task.Delay(4000);
                }
            }
            catch (AccessTokenNotAvailableException ex)
            {
                pollingCancellationToken.Cancel();
                ex.Redirect();
            }
            catch (Exception ex)
            {
                invalidOrder = true;
                pollingCancellationToken.Cancel();
                Console.Error.WriteLine(ex);
                StateHasChanged();
            }
        }
    }
    // Metodo que nos permite liberar la memoria en caso de cancelar las peticiones
    void IDisposable.Dispose()
    {
        pollingCancellationToken?.Cancel();
    }
}
